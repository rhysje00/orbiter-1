// action_global.C
//
// Anton Betten
// October 10, 2013

#include "galois.h"
#include "action.h"

static void print_from_to(INT d, INT i, INT j, INT *v1, INT *v2);

action *create_induced_action_by_restriction(action *A, sims *S, INT size, INT *set, INT f_induce, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_by_restriction" << endl;
		}
	A2 = new action;
	//A2->induced_action_by_restriction(*A, S, size, set, f_induce, verbose_level - 1);
	A2->induced_action_by_restriction(*A, f_induce,  S, size, set, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_by_restriction done" << endl;
		}
	return A2;
}

action *create_induced_action_on_sets(action *A, sims *S, INT nb_sets, INT set_size, INT *sets, INT f_induce, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_on_sets" << endl;
		}
	A2 = new action;
	A2->induced_action_on_sets(*A, S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_on_sets done" << endl;
		}
	return A2;
}


void create_orbits_on_subset_using_restricted_action(action *&A_by_restriction, schreier *&Orbits, action *A, sims *S, INT size, INT *set, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action" << endl;
		}
	A_by_restriction = create_induced_action_by_restriction(A, S, size, set, f_induce, verbose_level - 1);
	Orbits = new schreier;

	A_by_restriction->compute_all_point_orbits(*Orbits, S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action done" << endl;
		}
	
}

void create_orbits_on_sets_using_action_on_sets(action *&A_on_sets, schreier *&Orbits, action *A, sims *S, INT nb_sets, INT set_size, INT *sets, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets" << endl;
		}
	A_on_sets = create_induced_action_on_sets(A, S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	Orbits = new schreier;

	A_on_sets->compute_all_point_orbits(*Orbits, S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets done" << endl;
		}
	
}


action *new_action_by_right_multiplication(sims *group_we_act_on, INT f_transfer_ownership, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A;

	if (f_v) {
		cout << "new_action_by_right_multiplication" << endl;
		}
	A = new action;
	A->induced_action_by_right_multiplication(FALSE /* f_basis */, NULL /* sims *old_G */, 
		group_we_act_on, f_transfer_ownership /* f_ownership */, verbose_level - 1);
	if (f_v) {
		cout << "new_action_by_right_multiplication done" << endl;
		}
	return A;
}

void action_print_symmetry_group_type(ostream &ost, symmetry_group_type a)
{
	if (a == unknown_symmetry_group_t) {
		ost << "unknown_symmetry_group_t";
		}
	else if (a == matrix_group_t) {
		ost << "matrix_group_t";
		}
#if 0
	else if (a == perm_group_dp_t) {
		ost << "perm_group_dp_t";
		}
#endif
	else if (a == perm_group_t) {
		ost << "perm_group_t";
		}
	else if (a == action_on_sets_t) {
		ost << "action_on_sets_t";
		}
	else if (a == action_on_pairs_t) {
		ost << "action_on_pairs_t";
		}
	else if (a == action_on_ordered_pairs_t) {
		ost << "action_on_ordered_pairs_t";
		}
	else if (a == base_change_t) {
		ost << "base_change_t";
		}
	else if (a == product_action_t) {
		ost << "product_action_t";
		}
	else if (a == action_by_right_multiplication_t) {
		ost << "action_by_right_multiplication_t";
		}
	else if (a == action_by_restriction_t) {
		ost << "action_by_restriction_t";
		}
	else if (a == action_by_conjugation_t) {
		ost << "action_by_conjugation_t";
		}
	else if (a == action_by_representation_t) {
		ost << "action_by_representation_t";
		}
	else if (a == action_by_subfield_structure_t) {
		ost << "action_by_subfield_structure_t";
		}
	else if (a == action_on_determinant_t) {
		ost << "action_on_determinant_t";
		}
	else if (a == action_on_grassmannian_t) {
		ost << "action_on_grassmannian_t";
		}
	else if (a == action_on_spread_set_t) {
		ost << "action_on_spread_set_t";
		}
	else if (a == action_on_cosets_t) {
		ost << "action_on_cosets_t";
		}
	else if (a == action_on_factor_space_t) {
		ost << "action_on_factor_space_t";
		}
	else if (a == action_on_wedge_product_t) {
		ost << "action_on_wedge_product_t";
		}
	else if (a == action_on_bricks_t) {
		ost << "action_on_bricks_t";
		}
	else if (a == action_on_andre_t) {
		ost << "action_on_andre_t";
		}
	else if (a == action_on_orthogonal_t) {
		ost << "action_on_orthogonal_t";
		}
	else {
		ost << "unknown symmetry_group_type" << endl;
		}
}

INT choose_next_base_point_default_method(action *A, INT *Elt, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT b;
	
	if (f_v) {
		cout << "choose_next_base_point_default_method" << endl;
		cout << "calling A->find_non_fixed_point" << endl;
		}
	b = A->find_non_fixed_point(Elt, verbose_level - 1);
	if (b == -1) {
		if (f_v) {
			cout << "cannot find another base point" << endl;
			}
		return -1;
		}
	if (f_v) {
		cout << "choose_next_base_point_default_method current base: ";
		INT_vec_print(cout, A->base, A->base_len);
		cout << " choosing next base point to be " << b << endl;
		}
	return b;
}

void make_generators_stabilizer_of_two_components(action *A_PGL_n_q, action *A_PGL_k_q, 
	INT k, vector_ge *gens, INT verbose_level)
// used in semifield.C
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT *Q;
	INT *Elt1;
	INT *Zero;
	INT *Id;
	INT *Center;
	INT *minusId;
	INT n, i, len;
	INT *P;
	matrix_group *Mtx;
	finite_field *Fq;
	INT minus_one, alpha;
	strong_generators *gens_PGL_k;
	//vector_ge *gens_PGL_k;


	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_INT(k * k);
	Id = NEW_INT(k * k);
	Center = NEW_INT(k * k);
	minusId = NEW_INT(k * k);
	Q = NEW_INT(n * n + 1);
	Elt1 = NEW_INT(A_PGL_n_q->elt_size_in_INT);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);
	alpha = Fq->primitive_root();

	INT_vec_zero(Zero, k * k);
	INT_vec_zero(Id, k * k);
	INT_vec_zero(Center, k * k);
	INT_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		Center[i * k + i] = alpha;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	INT *Data;
	INT new_len, sz, idx, h;

	new_len = 2 * len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_INT(new_len * sz);
	idx = 0;
	for (h = 0; h < 2 * len; h++) {

		P = gens_PGL_k->gens->ith(h / 2);
		//P = gens_PGL_k->ith(h / 2);

		if (EVEN(h)) {
			// Q := diag(P,Id)
			INT_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, Id);
			}
		else {
			// Q := diag(Id,P)
			INT_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, P);
			}
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		INT_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

#if 0
	// Q := matrix(0,I,I,0):
	INT_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	INT_vec_copy(Q, Data + idx * sz, sz);
	idx++;
#endif

	// Q := matrix(Center,0,0,I):
	INT_matrix_make_block_matrix_2x2(Q, k, Center, Zero, Zero, Id);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	INT_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(I,0,0,Center):
	INT_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, Center);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	INT_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_two_components idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_two_components after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_INT(Data);

	FREE_INT(Zero);
	FREE_INT(Id);
	FREE_INT(Center);
	FREE_INT(minusId);
	FREE_INT(Q);
	FREE_INT(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components done" << endl;
		}
}


void make_generators_stabilizer_of_three_components(action *A_PGL_n_q, action *A_PGL_k_q, 
	INT k, vector_ge *gens, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT *Q;
	INT *Elt1;
	INT *Zero;
	INT *Id;
	INT *minusId;
	INT n, i, len;
	INT *P;
	matrix_group *Mtx;
	finite_field *Fq;
	INT minus_one;
	strong_generators *gens_PGL_k;
	//vector_ge *gens_PGL_k;


	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_INT(k * k);
	Id = NEW_INT(k * k);
	minusId = NEW_INT(k * k);
	Q = NEW_INT(n * n + 1);
	Elt1 = NEW_INT(A_PGL_n_q->elt_size_in_INT);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);


	INT_vec_zero(Zero, k * k);
	INT_vec_zero(Id, k * k);
	INT_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	INT *Data;
	INT new_len, sz, idx, h;

	new_len = len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_INT(new_len * sz);
	idx = 0;
	for (h = 0; h < len; h++) {

		P = gens_PGL_k->gens->ith(h);
		//P = gens_PGL_k->ith(h);

		// Q := diag(P,P)
		INT_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, P);
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		INT_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

	// Q := matrix(0,I,I,0):
	INT_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	INT_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(0,I,-I,-I):
	INT_matrix_make_block_matrix_2x2(Q, k, Zero, Id, minusId, minusId);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	INT_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_three_components idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_three_components after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_INT(Data);

	FREE_INT(Zero);
	FREE_INT(Id);
	FREE_INT(minusId);
	FREE_INT(Q);
	FREE_INT(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components done" << endl;
		}
}

void generators_to_strong_generators(action *A, 
	INT f_target_go, longinteger_object &target_go, 
	vector_ge *gens, strong_generators *&Strong_gens, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	longinteger_object go;
	longinteger_domain D;

	if (f_v) {
		cout << "generators_to_strong_generators" << endl;
		}

	sims *G, *K;
	G = new sims;
	K = new sims;
	G->init(A);
	K->init(A);
	K->init_trivial_group(0);
	G->init_trivial_group(0);
	if (f_v) {
		cout << "generators_to_strong_generators before G->build_up_group_from_generators, target_go = " << target_go << endl;
		}
	G->build_up_group_from_generators(K, gens, 
		f_target_go, &target_go, 
		FALSE /*f_override_choose_next_base_point */,
		NULL /*INT (*choose_next_base_point_method)(action *A, INT *Elt, INT verbose_level)*/, 
		verbose_level - 2);

	

	
	G->group_order(go);

	INT nb_times = 200;
	
	while (TRUE) {
		if (D.compare_unsigned(go, target_go) == 0) {
			cout << "generators_to_strong_generators: group orders match, we are done" << endl;
			break;
			}
	
		cout << "generators_to_strong_generators: group orders do not match" << endl;
		cout << "go = " << go << endl;
		cout << "target_go = " << target_go << endl;
		
		cout << "generators_to_strong_generators: calling closure_group" << endl;
		G->closure_group(nb_times, 0/*verbose_level*/);
		G->group_order(go);
		if (f_v) {
			cout << "new group order go=" << go << endl;
			}
		}
	if (f_v) {
		cout << "generators_to_strong_generators reached group of order " << go << endl;
		cout << "extracting strong generators:" << endl;
		}

	Strong_gens = new strong_generators;
	Strong_gens->init_from_sims(G, 0);

#if 0
	G->extract_strong_generators_in_order(*strong_gens, tl, 0/*verbose_level - 2*/);
	if (f_v) {
		cout << "tl: ";
		INT_vec_print(cout, tl, A->base_len);
		cout << endl;
		}
	if (f_v) {
		cout << "there are " << strong_gens->len << " strong generators:" << endl;
		}
#endif
	if (f_vv) {
		INT h;
		for (h = 0; h < Strong_gens->gens->len; h++) {
			cout << "generator " << h << ":" << endl;
			//cout << "in action A0:" << endl;
			//A0->element_print(gens.ith(h), cout);
			cout << "in action A:" << endl;
			A->element_print(Strong_gens->gens->ith(h), cout);
			}
		}
	delete G;
	delete K;

	if (f_v) {
		cout << "generators_to_strong_generators done" << endl;
		}
}

void compute_generators_GL_n_q(INT *&Gens, INT &nb_gens, INT &elt_size, INT n, finite_field *F, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	action *A;
	vector_ge *gens;
	INT *Elt;
	INT h, i, l, alpha;
	matrix_group *M;

	if (f_v) {
		cout << "compute_generators_GL_n_q" << endl;
		}
	A = new action;

	A->init_projective_group(n, F, FALSE /* f_semilinear */, TRUE /* f_basis */, verbose_level - 2);
	M = A->G.matrix_grp;

	gens = A->Strong_gens->gens;
	//gens = A->strong_generators;

	l = gens->len;
	nb_gens = l + 1;
	elt_size = n * n;
	Gens = NEW_INT(nb_gens * elt_size);
	for (h = 0; h < nb_gens; h++) {
		if (h < l) {
			Elt = gens->ith(h);
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = Elt[i];
				}
			}
		else {
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = 0;
				}
			alpha = F->primitive_root();
			for (i = 0; i < n; i++) {
				Gens[h * elt_size + i * n + i] = alpha;
				}
			}
		}
	if (f_vv) {
		for (h = 0; h < nb_gens; h++) {
			cout << "Generator " << h << ":" << endl;
			INT_matrix_print(Gens + h * elt_size, n, n);
			}
		
		}
	delete A;
	//delete F;
	if (f_v) {
		cout << "compute_generators_GL_n_q done" << endl;
		}
}

void order_of_PGGL_n_q(longinteger_object &go, INT n, INT q, INT f_semilinear)
{
	INT verbose_level = 0;
	action *A;
	finite_field *F;

	F = new finite_field;
	A = new action;

	F->init(q, 0);
	A->init_projective_group(n, F, 
		f_semilinear, 
		TRUE /* f_basis */, verbose_level - 2);
	A->group_order(go);
	
	delete F;
	delete A;
}


// callbacks for Schreier Sims:


	INT f_generator_orthogonal_siegel = TRUE;
	INT f_generator_orthogonal_reflection = TRUE;
	INT f_generator_orthogonal_similarity = TRUE;
	INT f_generator_orthogonal_semisimilarity = TRUE;


void set_orthogonal_group_type(INT f_siegel, INT f_reflection, INT f_similarity, INT f_semisimilarity)
{
	f_generator_orthogonal_siegel = f_siegel;
	f_generator_orthogonal_reflection = f_reflection;
	f_generator_orthogonal_similarity = f_similarity;
	f_generator_orthogonal_semisimilarity = f_semisimilarity;
}

void callback_choose_random_generator_orthogonal(INT iteration, 
	INT *Elt, void *data, INT verbose_level)
{
	//verbose_level += 5;
	INT f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal iteration=" << iteration << endl;
		}

	schreier_sims *ss = (schreier_sims *) data;
	action *A = ss->GA;
	action *subaction = ss->KA;
	matrix_group *M;
#if 0
	INT f_siegel = TRUE;
	INT f_reflection = TRUE;
	INT f_similarity = TRUE;
	INT f_semisimilarity = TRUE;
#endif

	action_on_orthogonal *AO;
	orthogonal *O;
	
	AO = A->G.AO;
	O = AO->O;
	
	M = subaction->G.matrix_grp;
	M->orthogonal_group_random_generator(ss->GA, O, 
		f_generator_orthogonal_siegel, 
		f_generator_orthogonal_reflection, 
		f_generator_orthogonal_similarity, 
		f_generator_orthogonal_semisimilarity, 
		Elt, verbose_level - 2);
	//M->GL_invert_internal(Elt, Elt + M->elt_size_INT_half, 0);

}

#if 0
void callback_choose_random_generator_orthogonal_but_no_reflection(INT iteration, 
	INT *Elt, void *data, INT verbose_level)
{
	//verbose_level += 5;
	INT f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal iteration=" << iteration << endl;
		}

	schreier_sims *ss = (schreier_sims *) data;
	action *A = ss->GA;
	action *subaction = ss->KA;
	matrix_group *M;
	INT f_siegel = TRUE;
	INT f_reflection = FALSE;
	INT f_similarity = TRUE;
	INT f_semisimilarity = TRUE;
	action_on_orthogonal *AO;
	orthogonal *O;
	
	AO = A->G.AO;
	O = AO->O;
	
	
	M = subaction->G.matrix_grp;
	M->orthogonal_group_random_generator(ss->GA, O, 
		f_siegel, f_reflection, f_similarity, f_semisimilarity, 
		Elt, verbose_level - 2);
	//M->GL_invert_internal(Elt, Elt + M->elt_size_INT_half, 0);

}
#endif


#if 0
INT choose_next_base_point_ovoidal_method(action *A, INT *Elt, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT i, a, b, c, f;
	matrix_group *M;
	orthogonal *O;
	
	M = A->subaction->G.matrix_grp;
	if (M == NULL) {
		cout << "choose_next_base_point_ovoidal_method M == NULL" << endl;
		exit(1);
		}
	O = M->O;
	if (O == NULL) {
		cout << "choose_next_base_point_ovoidal_method O == NULL" << endl;
		exit(1);
		}

	for (b = 0; b < A->degree; b++) {
		for (i = 0; i < A->base_len; i++) {
			a = A->base[i];
			if (a == b)
				break;
			f = O->evaluate_bilinear_form_by_rank(a, b);
			if (f == 0)
				break;
			}
		if (i < A->base_len)
			continue;
		c = A->element_image_of(b, Elt, FALSE);
		if (c != b) {
			if (f_v) {
				cout << "moves " << b << " to " << c << endl;
				}
			break;
			}
		}
	if (b == A->degree) {
		cout << "choose_next_base_point_ovoidal_method did not find another base point" << endl;
		exit(1);
		}
	if (f_v) {
		cout << "choose_next_base_point_ovoidal_method current base: ";
		INT_vec_print(cout, A->base, A->base_len);
		cout << " choosing next base point to be " << b << endl;
		}
	return b;
}
#endif


void test_matrix_group(INT k, INT q, INT f_semilinear, INT verbose_level)
{
	action A;
	finite_field *F;
	INT f_basis = TRUE;
	
	F = new finite_field;
	F->init(q, 0);
	A.init_projective_group(k, F, f_semilinear, f_basis, verbose_level);
	delete F;
}

void lift_generators(vector_ge *gens_in, vector_ge *&gens_out, 
	action *Aq, subfield_structure *S, INT n, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT *EltQ;
	INT *Eltq;
	INT *Mtx;
	INT nb_gens, m, t;


	if (f_v) {
		cout << "lift_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = new vector_ge;

	Eltq = NEW_INT(Aq->elt_size_in_INT);
	Mtx = NEW_INT(n * n);

	if (f_v) {
		cout << "lift_generators lifting generators" << endl;
		}
	gens_out->init(Aq);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "lift_generators " << t << " / " << nb_gens << endl;
			}
		EltQ = gens_in->ith(t);
		S->lift_matrix(EltQ, m, Mtx, 0 /* verbose_level */);
		if (f_vv) {
			cout << "lift_generators lifted matrix:" << endl;
			INT_matrix_print(Mtx, n, n);
			}
		Aq->make_element(Eltq, Mtx, 0 /*verbose_level - 4 */);
		if (f_vv) {
			cout << "lift_generators after make_element:" << endl;
			Aq->element_print_quick(Eltq, cout);
			}
		Aq->element_move(Eltq, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "lift_generators " << t << " / " << nb_gens << " done" << endl;
			}
		}
	FREE_INT(Eltq);
	FREE_INT(Mtx);
	if (f_v) {
		cout << "lift_generators done" << endl;
		}

}

void retract_generators(vector_ge *gens_in, vector_ge *&gens_out, 
	action *AQ, subfield_structure *S, INT n, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT *EltQ;
	INT *Eltq;
	INT *Mtx;
	INT nb_gens, m, t;


	if (f_v) {
		cout << "retract_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = new vector_ge;

	EltQ = NEW_INT(AQ->elt_size_in_INT);
	Mtx = NEW_INT(m * m);

	if (f_v) {
		cout << "retract_generators retracting generators" << endl;
		}
	gens_out->init(AQ);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "retract_generators " << t << 
" / " << nb_gens << endl;
			}
		Eltq = gens_in->ith(t);
		S->retract_matrix(Eltq, n, Mtx, m, 0 /* verbose_level */);
		if (f_vv) {
			cout << "retract_generators retracted matrix:" << endl;
			INT_matrix_print(Mtx, m, m);
			}
		AQ->make_element(EltQ, Mtx, 0 /*verbose_level - 4*/);
		if (f_vv) {
			cout << "retract_generators after make_element:" << endl;
			AQ->element_print_quick(EltQ, cout);
			}
		AQ->element_move(EltQ, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "retract_generators " << t << 
" / " << nb_gens << " done" << endl;
			}
		}
	FREE_INT(EltQ);
	FREE_INT(Mtx);
	if (f_v) {
		cout << "retract_generators done" << endl;
		}

}

void lift_generators_to_subfield_structure(
	INT n, INT s, 
	subfield_structure *S, 
	action *Aq, action *AQ, 
	strong_generators *&Strong_gens, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT q, Q, m;
	finite_field *Fq;
	finite_field *FQ;
	sims *Sims;

	if (f_v) {
		cout << "lift_generators_to_subfield_structure" << endl;
		}
	Fq = S->Fq;
	FQ = S->FQ;
	q = Fq->q;
	Q = i_power_j(q, s);
	m = n / s;
	if (m * s != n) {
		cout << "lift_generators_to_subfield_structure s must divide n" << endl;
		exit(1);
		}
	if (f_v) {
		cout << "lift_generators_to_subfield_structure creating subfield structure" << endl;
		}
	if (f_v) {
		cout << "n=" << n << endl;
		cout << "s=" << s << endl;
		cout << "m=" << m << endl;
		cout << "q=" << q << endl;
		cout << "Q=" << Q << endl;
		}

	longinteger_object order_GLmQ;
	longinteger_object target_go;
	longinteger_domain D;
	INT r;

	AQ->group_order(order_GLmQ);
	

	if (f_v) {
		cout << "lift_generators_to_subfield_structure order of GL(m,Q) = " << order_GLmQ << endl;
		}
	D.integral_division_by_INT(order_GLmQ, 
		q - 1, target_go, r);
	if (f_v) {
		cout << "lift_generators_to_subfield_structure target_go = " << target_go << endl;
		}



	vector_ge *gens;
	vector_ge *gens1;


	gens = AQ->Strong_gens->gens;


	if (f_v) {
		cout << "lift_generators_to_subfield_structure before lift_generators" << endl;
		}
	lift_generators(gens, gens1, Aq, S, n, verbose_level);
		// ACTION/action_global.C
	if (f_v) {
		cout << "lift_generators_to_subfield_structure after lift_generators" << endl;
		}


	if (f_v) {
		cout << "lift_generators_to_subfield_structure creating lifted group:" << endl;
		}
	//Aq->group_order(target_go);
	Sims = create_sims_from_generators_with_target_group_order(Aq, 
		gens1, 
		target_go, 
		0 /* verbose_level */);

#if 0
	Sims = create_sims_from_generators_without_target_group_order(Aq, 
		gens1, MINIMUM(2, verbose_level - 3));
#endif

	if (f_v) {
		cout << "lift_generators_to_subfield_structure creating lifted group done" << endl;
		}

	longinteger_object go;

	Sims->group_order(go);

	if (f_v) {
		cout << "go=" << go << endl;
		}


	Strong_gens = new strong_generators;

	Strong_gens->init_from_sims(Sims, 0 /* verbose_level */);
	if (f_vv) {
		cout << "lift_generators_to_subfield_structure strong generators are:" << endl;
		Strong_gens->print_generators();
		}


	delete gens1;
	delete Sims;
	if (f_v) {
		cout << "lift_generators_to_subfield_structure done" << endl;
		}

}



void create_linear_group(sims *&S, action *&A, 
	finite_field *F, INT m, 
	INT f_projective, INT f_general, INT f_affine, 
	INT f_semilinear, INT f_special, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	//INT f_vv = (verbose_level >= 2);
	INT f_basis = TRUE;
	
	if (f_v) {
		cout << "create_linear_group m=" << m << " q=" << F->q << endl;
		}

	A = new action;

	if (f_projective) {
		A->init_projective_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else if (f_general) {
		A->init_general_linear_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else if (f_affine) {
		A->init_affine_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else {
		cout << "create_linear_group the type of group is not specified" << endl;
		exit(1);
		}


	if (!A->f_has_strong_generators) {
		cout << "create_linear_group fatal: !A->f_has_strong_generators" << endl;
		}



	if (f_special) {


		if (f_v) {
			cout << "create_linear_group computing intersection with special linear group" << endl;
			}


		action A_on_det;
		longinteger_object go;
		
		A_on_det.induced_action_on_determinant(A->Sims, verbose_level);
		if (f_v) {
			cout << "create_linear_group induced_action_on_determinant finished" << endl;
			}
		A_on_det.Kernel->group_order(go);
		if (f_v) {
			cout << "create_linear_group intersection has order " << go << endl;
			}


		S = A_on_det.Strong_gens->create_sims(0 /* verbose_level */);

		}
	else {

		S = A->Strong_gens->create_sims(0 /* verbose_level */);
		}


#if 0
	vector_ge *SG;
	INT *tl;

	SG = new vector_ge;
	tl = NEW_INT(A->base_len);
	A->get_strong_generators(SG, tl, verbose_level - 1);

	sims *Sims;
	
	Sims = new sims;
	Sims->init(A);
	Sims->init_trivial_group(verbose_level - 1);
	Sims->init_generators(*A->strong_generators, FALSE);
	Sims->compute_base_orbits(verbose_level - 1);
	
	A->f_has_sims = TRUE;
	A->Sims = Sims;

	cout << "action sims initialized" << endl;
	
	if (linear_f_special) {
		action A_on_det;
		longinteger_object go;
		
		cout << "computing intersection with special linear group" << endl;
		A_on_det.induced_action_on_determinant(A->Sims, verbose_level);
		cout << "induced_action_on_determinant finished" << endl;
		A_on_det.Kernel->group_order(go);
		cout << "intersection has order " << go << endl;
		//A_on_det.Kernel->compute_strong_generators(*SG, verbose_level - 1);
		A_on_det.Kernel->extract_strong_generators_in_order(*SG, tl, verbose_level - 1);
		
		sims *Sims2;
		
		Sims2 = new sims;
		Sims2->init(A);
		Sims2->init_trivial_group(verbose_level - 1);
		Sims2->init_generators(*SG, FALSE);
		Sims2->compute_base_orbits(verbose_level - 1);
	
		A->init_sims(Sims2, verbose_level);
		}
#endif

	
	


	
	if (f_v) {
		A->print_base();
		if (f_projective) {
			display_all_PG_elements(m - 1, *F);
			}
		}
	
	

	if (f_v) {
		cout << "create_linear_group finished" << endl;
		}
}



#if 0
action *create_automorphism_group_of_graph(
	INT n, INT *Adj, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT parts[1];
	action *A;
	INT *labeling;

	parts[0] = n;
	labeling = NEW_INT(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph" << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(n, FALSE, NULL, Adj, 1, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph done" << endl;
		}
	FREE_INT(labeling);
	return A;
}
#endif
action *create_automorphism_group_of_colored_graph_object(colored_graph *CG, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A;

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph" << endl;
		}

	A = create_automorphism_group_of_colored_graph(
		CG->nb_points, TRUE /* f_bitvec */, CG->bitvector_adjacency, NULL /* INT  *Adj */, 
		CG->point_color, 
		verbose_level);

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_colored_graph(
	INT n, INT f_bitvec, UBYTE *Adj_bitvec, INT *Adj, 
	INT *vertex_colors, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A;
	UBYTE *Adj1;
	INT *labeling;
	INT *parts;
	INT nb_parts;
	INT i, j, k, n1, N, len, f_on, c, nb_edges;

	labeling = NEW_INT(n);

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph" << endl;
		}

	classify C;

	C.init(vertex_colors, n, FALSE, 0);


	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph nb_types = " << C.nb_types << endl;
		}


	n1 = n + C.nb_types;

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph n1 = " << n1 << endl;
		}

	N = (n1 * (n1 - 1)) >> 1;
	len = (N + 7) >> 3;
	Adj1 = NEW_UBYTE(len);
	for (i = 0; i < len; i++) {
		Adj1[i] = 0;
		}

	nb_edges = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			k = ij2k(i, j, n);
			if (f_bitvec) {
				if (bitvector_s_i(Adj_bitvec, k)) {
					f_on = TRUE;
					}
				}
			else {
				f_on = Adj[i * n + j];
				}
			if (f_on) {
				k = ij2k(i, j, n1);
				bitvector_m_ii(Adj1, k, 1);
				nb_edges++;
				}
			}
		}
	for (i = 0; i < n; i++) {
		c = C.class_of(i);
		j = n + c;
		k = ij2k(i, j, n1);
		bitvector_m_ii(Adj1, k, 1);
		}


	nb_parts = 1 + C.nb_types;
	parts = NEW_INT(nb_parts);
	parts[0] = n;
	for (i = 0; i < C.nb_types; i++) {
		parts[1 + i] = 1;
		}
	
	

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph before create_automorphism_group_of_graph_with_partition_and_labeling" << endl;
		cout << "nb_edges=" << nb_edges << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(n1, TRUE, Adj1, NULL, nb_parts, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph done" << endl;
		}

	FREE_INT(parts);
	FREE_INT(labeling);
	FREE_UBYTE(Adj1);
	return A;
}

action *create_automorphism_group_of_graph_bitvec(
	INT n, UBYTE *Adj_bitvec, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT parts[1];
	action *A;
	INT *labeling;

	parts[0] = n;
	labeling = NEW_INT(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_bitvec" << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(n, TRUE, Adj_bitvec, NULL, 1, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph_bitvec done" << endl;
		}
	FREE_INT(labeling);
	return A;
}

action *create_automorphism_group_of_graph_with_partition_and_labeling(
	INT n, 
	INT f_bitvector, UBYTE *Adj_bitvec, INT *Adj, 
	INT nb_parts, INT *parts, 
	INT *labeling, 
	INT verbose_level)
// labeling[n]
{
	INT f_v = (verbose_level >= 1);
	INT f_v10 = (verbose_level >= 10);
	//INT *labeling; //, *labeling_inv;
	INT *Aut;
	INT *Base, *Transversal_length, *partitions;
	INT Aut_counter = 0, Base_length = 0, Ago = 0;
	INT i, u, a;
	
	
	//m = # rows
	//n = # cols
	
	Aut = NEW_INT(n * n);
	Base = NEW_INT(n);
	Transversal_length = NEW_INT(n);
	partitions = NEW_INT(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_with_partition_and_labeling" << endl;
		}
	for (i = 0; i < n; i++) {
		partitions[i] = 1;
		}
	u = 0;
	for (i = 0; i < nb_parts; i++) {
		a = parts[i];
		u += a;
		partitions[u - 1] = 0;
		}
	if (u != n) {
		cout << "create_automorphism_group_of_graph_with_partition_and_labeling partition does not add up" << endl;
		exit(1);
		}

	//partitions[n - 1] = 0;

	//labeling = NEW_INT(n);
	//labeling_inv = NEW_INT(n);
	
	if (f_bitvector) {
		if (f_v) {
			cout << "create_automorphism_group_of_graph_with_partition_and_labeling before nauty_interface_graph_bitvec" << endl;
			}
		nauty_interface_graph_bitvec(n, Adj_bitvec, 
			labeling, partitions, 
			Aut, Aut_counter, 
			Base, Base_length, 
			Transversal_length, Ago, verbose_level);
		}
	else {
		nauty_interface_graph_INT(n, Adj, 
			labeling, partitions, 
			Aut, Aut_counter, 
			Base, Base_length, 
			Transversal_length, Ago, verbose_level);
		}

	if (f_v) {
		if (TRUE /*(input_no % 500) == 0*/) {
			cout << "create_automorphism_group_of_graph_with_partition_and_labeling: The group order is = " << Ago << endl;
			cout << "transversal length: ";
			INT_vec_print(cout, Transversal_length, Base_length);
			cout << endl;
			}
		}

#if 0
	for (i = 0; i < n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	if (f_v10) {
		cout << "create_automorphism_group_of_graph_with_partition_and_labeling: labeling:" << endl;
		INT_vec_print(cout, labeling, n);
		cout << endl;
		//cout << "labeling_inv:" << endl;
		//INT_vec_print(cout, labeling_inv, n);
		//cout << endl;

		cout << "create_automorphism_group_of_graph_with_partition_and_labeling: Base:" << endl;
		INT_vec_print(cout, Base, Base_length);
		cout << endl;

		cout << "create_automorphism_group_of_graph_with_partition_and_labeling: generators:" << endl;
		print_integer_matrix_width(cout, Aut, Aut_counter, n, n, 2);
		}



	action *A;


	A = new action;

	A->init_permutation_group_from_generators(n, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level - 2);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_with_partition_and_labeling: created action ";
		A->print_info();
		cout << endl;
		}

	FREE_INT(Aut);
	FREE_INT(Base);
	FREE_INT(Transversal_length);
	FREE_INT(partitions);
	//FREE_INT(labeling);

	return A;
}

void create_incidence_matrix_of_graph(INT *Adj, INT n, INT *&M, INT &nb_rows, INT &nb_cols, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT i, j, u;
	
	if (f_v) {
		cout << "create_incidence_matrix_of_graph" << endl;
		}
	nb_rows = n;
	nb_cols = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			if (Adj[i * n + j]) {
				nb_cols++;
				}
			}
		}
	M = NEW_INT(n * nb_cols);
	INT_vec_zero(M, n * nb_cols);
#if 0
	for (i = 0; i < n * nb_cols; i++) {
		M[i] = 0;
		}
#endif
	u = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			if (Adj[i * n + j]) {
				M[i * nb_cols + u] = 1;
				M[j * nb_cols + u] = 1;
				u++;
				}
			}
		}
	if (f_v) {
		cout << "create_incidence_matrix_of_graph done" << endl;
		}

}


action *create_automorphism_group_of_graph(INT *Adj, INT n, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT *M;
	action *A;
	INT nb_rows, nb_cols;

	if (f_v) {
		cout << "create_automorphism_group_of_graph" << endl;
		}
	create_incidence_matrix_of_graph(Adj, n, M, nb_rows, nb_cols, verbose_level);
	A = create_automorphism_group_of_incidence_matrix(
		nb_rows, nb_cols, M, verbose_level);
	
	FREE_INT(M);
	if (f_v) {
		cout << "create_automorphism_group_of_graph done" << endl;
		}
	return A;
}


action *create_automorphism_group_of_block_system(
	INT nb_points, INT nb_blocks, INT block_size, INT *Blocks, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT *M;
	action *A;
	INT i, j, h;	
	
	if (f_v) {
		cout << "create_automorphism_group_of_block_system" << endl;
		}
	M = NEW_INT(nb_points * nb_blocks);
	for (i = 0; i < nb_points * nb_blocks; i++) {
		M[i] = 0;
		}
	for (j = 0; j < nb_blocks; j++) {
		for (h = 0; h < block_size; h++) {
			i = Blocks[j * block_size + h];
			M[i * nb_blocks + j] = 1;
			}
		}
	A = create_automorphism_group_of_incidence_matrix(
		nb_points, nb_blocks, M, verbose_level);

	FREE_INT(M);
	if (f_v) {
		cout << "create_automorphism_group_of_block_system done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_incidence_matrix(
	INT m, INT n, INT *Mtx, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT nb_inc;
	INT *X;
	action *A;
	INT i, j, h;	
	
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_matrix" << endl;
		}
	nb_inc = 0;
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			if (Mtx[i * n + j]) {
				nb_inc++;
				}
			}
		}
	X = NEW_INT(nb_inc);
	h = 0;
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			if (Mtx[i * n + j]) {
				X[h++] = i * n + j;
				}
			}
		}
	A = create_automorphism_group_of_incidence_structure_low_level(
		m, n, nb_inc, X, verbose_level);

	FREE_INT(X);
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_matrix done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_incidence_structure(
	incidence_structure *Inc, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action *A;
	INT m, n, nb_inc;
	INT *X;
	INT *data;
	INT nb;
	INT i, j, h, a;
	
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_structure" << endl;
		}
	m = Inc->nb_points();
	n = Inc->nb_lines();
	nb_inc = Inc->get_nb_inc();
	X = NEW_INT(nb_inc);
	data = NEW_INT(n);
	h = 0;
	for (i = 0; i < m; i++) {
		nb = Inc->get_lines_on_point(data, i);
		for (j = 0; j < nb; j++) {
			a = data[j];
			X[h++] = i * m + a;
			}
		}
	if (h != nb_inc) {
		cout << "create_automorphism_group_of_incidence_structure h != nb_inc" << endl;
		exit(1);
		}

	A = create_automorphism_group_of_incidence_structure_low_level(
		m, n, nb_inc, X, 
		verbose_level - 1);

	FREE_INT(X);
	FREE_INT(data);
	return A;
}

action *create_automorphism_group_of_incidence_structure_low_level(
	INT m, INT n, INT nb_inc, INT *X, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_v10 = (verbose_level >= 10);
	INT *labeling; //, *labeling_inv;
	INT *Aut;
	INT *Base, *Transversal_length, *partitions;
	INT Aut_counter = 0, Base_length = 0, Ago = 0;
	INT i;
	
	
	//m = # rows
	//n = # cols
	
	Aut = NEW_INT((m+n) * (m+n));
	Base = NEW_INT(m+n);
	Transversal_length = NEW_INT(m + n);
	partitions = NEW_INT(m + n);

	if (f_v) {
		cout << "create_automorphism_group_of_incidence_structure_low_level" << endl;
		}
	for (i = 0; i < m + n; i++) {
		partitions[i] = 1;
		}

	partitions[m - 1] = 0;

	labeling = NEW_INT(m + n);
	//labeling_inv = NEW_INT(m + n);

	nauty_interface_INT(m, n, X, nb_inc, 
		labeling, partitions, 
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago);

	if (f_v) {
		if (TRUE /*(input_no % 500) == 0*/) {
			cout << "create_automorphism_group_of_incidence_structure_low_level: The group order is = " << Ago << endl;
			}
		}

#if 0
	for (i = 0; i < m + n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	if (f_v10) {
		cout << "create_automorphism_group_of_incidence_structure_low_level: labeling:" << endl;
		INT_vec_print(cout, labeling, m + n);
		cout << endl;
		//cout << "labeling_inv:" << endl;
		//INT_vec_print(cout, labeling_inv, m + n);
		//cout << endl;

		cout << "create_automorphism_group_of_incidence_structure_low_level: Base:" << endl;
		INT_vec_print(cout, Base, Base_length);
		cout << endl;

		cout << "create_automorphism_group_of_incidence_structure_low_level: generators:" << endl;
		print_integer_matrix_width(cout, Aut, Aut_counter, m + n, m + n, 2);
		}



	action *A;


	A = new action;

	A->init_permutation_group_from_generators(m + n, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level - 2);

	if (f_v) {
		cout << "create_automorphism_group_of_incidence_structure_low_level: created action ";
		A->print_info();
		cout << endl;
		}

	FREE_INT(Aut);
	FREE_INT(Base);
	FREE_INT(Transversal_length);
	FREE_INT(partitions);
	FREE_INT(labeling);

	return A;
}

void test_self_dual_self_polar(INT input_no, INT m, INT n, INT nb_inc, INT *X, 
	INT &f_self_dual, INT &f_self_polar, INT verbose_level)
{
	INT M, N, i, j, h, Nb_inc, a;
	INT *Mtx, *Y;
	
	if (m != n) {
		f_self_dual = FALSE;
		f_self_polar = FALSE;
		return;
		}
	M = 2 * m;
	N = 2 + nb_inc;
	Mtx = NEW_INT(M * N);
	Y = NEW_INT(M * N);
	for (i = 0; i < M * N; i++) {
		Mtx[i] = 0;
		}
	for (i = 0; i < m; i++) {
		Mtx[i * N + 0] = 1;
		}
	for (i = 0; i < m; i++) {
		Mtx[(m + i) * N + 1] = 1;
		}
	for (h = 0; h < nb_inc; h++) {
		a = X[h];
		i = a / n;
		j = a % n;
		Mtx[i * N + 2 + h] = 1;
		Mtx[(m + j) * N + 2 + h] = 1;
		}
	Nb_inc = 0;
	for (i = 0; i < M * N; i++) {
		if (Mtx[i]) {
			Y[Nb_inc++] = i;
			}
		}
	
	do_self_dual_self_polar(input_no, M, N, Nb_inc, Y, f_self_dual, f_self_polar, verbose_level - 1);

	FREE_INT(Mtx);
	FREE_INT(Y);
}


void do_self_dual_self_polar(INT input_no, INT m, INT n, INT nb_inc, INT *X, 
	INT &f_self_dual, INT &f_self_polar, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT *labeling; //, *labeling_inv;
	INT *Aut;
	INT *Base, *Transversal_length, *partitions;
	INT Aut_counter = 0, Base_length = 0, Ago = 0;
	INT i; //, j;
	
	//m = # rows
	//n = # cols
	
	if (ODD(m)) {
		f_self_dual = f_self_polar = FALSE;
		return;
		}
	Aut = NEW_INT((m+n) * (m+n));
	Base = NEW_INT(m+n);
	Transversal_length = NEW_INT(m + n);
	partitions = NEW_INT(m + n);

	if (f_v) {
		if ((input_no % 500) == 0) {
			cout << "do_self_dual_self_polar input_no=" << input_no << endl;
			}
		}
	for (i = 0; i < m + n; i++) {
		partitions[i] = 1;
		}

#if 0
	for (i = 0; i < PB.P.ht; i++) {
		j = PB.P.startCell[i] + PB.P.cellSize[i] - 1;
		partitions[j] = 0;
		}
#endif

#if 0
	j = 0;
	for (i = 0; i < nb_row_parts; i++) {
		l = row_parts[i];
		partitions[j + l - 1] = 0;
		j +=l;
		}
	for (i = 0; i < nb_col_parts; i++) {
		l = col_parts[i];
		partitions[j + l - 1] = 0;
		j +=l;
		}				
#endif

	labeling = NEW_INT(m + n);
	//labeling_inv = NEW_INT(m + n);

	nauty_interface_INT(m, n, X, nb_inc, labeling, partitions, Aut, Aut_counter, Base, Base_length, Transversal_length, Ago);

	if (f_vv) {
		if ((input_no % 500) == 0) {
			cout << "The group order is = " << Ago << endl;
			}
		}
	
#if 0
	for (i = 0; i < m + n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	INT *aut;
	INT *p_aut;
	INT h, a, b, c, m_half;

	m_half = m >> 1;
	aut = NEW_INT(Aut_counter * m);
	for (h = 0; h < Aut_counter; h++) {
		for (i = 0; i < m; i++) {
			aut[h * m + i] = Aut[h * (m + n) + i];
			}
		}
	f_self_dual = FALSE;
	f_self_polar = FALSE;
	for (h = 0; h < Aut_counter; h++) {
		p_aut = aut + h * m;

		a = p_aut[0];
		if (a >= m_half ) {
			f_self_dual = TRUE;
			if (f_v) {
				cout << "no " << input_no << " is self dual" << endl;
				}
			break;
			}
		}

#if 0

	INT *AUT;
	INT *BASE;

	AUT = NEW_INT(Aut_counter * (m + n));
	BASE = NEW_INT(Base_length);
	for (h = 0; h < Aut_counter; h++) {
		for (i = 0; i < m + n; i++) {
			j = labeling_inv[i];
			j = Aut[h * (m + n) + j];
			j = labeling[j];
			AUT[h * (m + 1) + i] = j;
			}
		}
	for (i = 0; i < Base_length; i++) {
		j = Base[i];
		j = labeling[j];
		BASE[i] = j;
		}
#endif

	action A;



	A.init_permutation_group_from_generators(m + n, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level);

	cout << "created action ";
	A.print_info();
	cout << endl;


	if (f_self_dual) {


		sims *S;
		longinteger_object go;
		INT goi;
		INT *Elt;
	
		S = A.Sims;
		S->group_order(go);
		goi = go.as_INT();
		Elt = NEW_INT(A.elt_size_in_INT);
		
		cout << "the group order is: " << goi << endl;
		for (i = 0; i < goi; i++) {
			S->element_unrank_INT(i, Elt);
			if (Elt[0] < m_half) {
				continue; // not a duality
				}
			
			for (a = 0; a < m_half; a++) {
				b = Elt[a];
				c = Elt[b];
				if (c != a)
					break;
				}
			if (a == m_half) {
				cout << "found a polarity:" << endl;
				A.element_print(Elt, cout);
				cout << endl;
				f_self_polar = TRUE;
				break;
				}
			}
		

		FREE_INT(Elt);
		}



		
	FREE_INT(aut);
	FREE_INT(Aut);
	FREE_INT(Base);
	FREE_INT(Transversal_length);
	FREE_INT(partitions);
	FREE_INT(labeling);
	//FREE_INT(labeling_inv);
	//FREE_INT(AUT);
	//FREE_INT(BASE);
}

void add_configuration_graph(ofstream &g, INT m, INT n, INT nb_inc, INT *X, INT f_first, INT verbose_level)
{
	incidence_structure Inc;
	INT *joining_table;
	INT *M1;
	INT i, j, h, nb_joined_pairs, nb_missing_pairs;
	INT n1, nb_inc1;
	action *A;
	longinteger_object ago;

	A = create_automorphism_group_of_incidence_structure_low_level(
			m, n, nb_inc, X, 
			verbose_level - 2);
	A->group_order(ago);

	Inc.init_by_incidences(m, n, nb_inc, X, verbose_level);
	joining_table = NEW_INT(m * m);
	for (i = 0; i < m * m; i++) {
		joining_table[i] = FALSE;
		}
	nb_joined_pairs = 0;
	for (i = 0; i < m; i++) {
		for (j = i + 1; j < m; j++) {
			for (h = 0; h < n; h++) {
				if (Inc.get_ij(i, h) && Inc.get_ij(j, h)) {
					joining_table[i * m + j] = TRUE;
					joining_table[j * m + i] = TRUE;
					nb_joined_pairs++;
					}
				}
			}
		}
	nb_missing_pairs = INT_n_choose_k(m, 2) - nb_joined_pairs;
	n1 = n + nb_missing_pairs;
	M1 = NEW_INT(m * n1);
	for (i = 0; i < m * n1; i++) {
		M1[i] = 0;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M1[i * n1 + j] = Inc.get_ij(i, j);
			}
		}
	h = 0;
	for (i = 0; i < m; i++) {
		for (j = i + 1; j < m; j++) {
			if (joining_table[i * m + j] == FALSE) {
				M1[i * n1 + n + h] = 1;
				M1[j * n1 + n + h] = 1;
				h++;
				}
			}
		}
	if (f_first) {
		nb_inc1 = 0;
		for (i = 0; i < m; i++) {
			for (j = 0; j < n1; j++) {
				if (M1[i * n1 + j]) {
					nb_inc1++;
					}
				}
			}
		g << m << " " << n1 << " " << nb_inc1 << endl;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n1; j++) {
			if (M1[i * n1 + j]) {
				g << i * n1 + j << " ";
				}
			}
		}
	g << ago << endl;
	
	FREE_INT(joining_table);
	FREE_INT(M1);
	delete A;
}

// O4_model:

void O4_isomorphism_2to4_embedded(action *A4, action *A5, finite_field *Fq, 
	INT f_switch, INT *mtx2x2_T, INT *mtx2x2_S, INT *Elt, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT mtx4x4[16];
	INT mtx5x5[25];
	INT *E1;
	
	if (f_v) {
		cout << "O4_isomorphism_2to4_embedded" << endl;
		}
	E1 = NEW_INT(A4->elt_size_in_INT);
	if (f_v) {
		cout << "input in 2x2, 2x2:" << endl;
		cout << "f_switch=" << f_switch << endl;
		print_integer_matrix_width(cout, mtx2x2_T, 2, 2, 2, 3);
		cout << "," << endl;
		print_integer_matrix_width(cout, mtx2x2_S, 2, 2, 2, 3);
		}
	
	O4_isomorphism_2to4(Fq, mtx2x2_T, mtx2x2_S, f_switch, mtx4x4);
	
	A4->make_element(E1, mtx4x4, 0);
	if (f_v) {
		cout << "in 4x4:" << endl;
		A4->element_print_quick(E1, cout);
		}
	
	O4_to_O5(A4, A5, Fq, E1, mtx5x5, verbose_level - 2);
	if (f_v) {
		cout << "in 5x5:" << endl;
		print_integer_matrix_width(cout, mtx5x5, 5, 5, 5, 3);
		}
	A5->make_element(Elt, mtx5x5, 0);
	if (f_v) {
		cout << "as group element:" << endl;
		A5->element_print_quick(Elt, cout);
		}
	FREE_INT(E1);
}

void O5_to_O4(action *A4, action *A5, finite_field *Fq, 
	INT *mtx4x4, INT *mtx5x5, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT Data[25];
	INT h, u, v;

	for (h = 0; h < 25; h++) {
		Data[h] = mtx5x5[h];
		}
	PG_element_normalize_from_front(*Fq, Data, 1, 25);
	if (f_v) {
		cout << "as 5 x 5:" << endl;
		print_integer_matrix_width(cout, Data, 5, 5, 5, 3);
		}

	for (u = 0; u < 4; u++) {
		for (v = 0; v < 4; v++) {
			mtx4x4[u * 4 + v] = Data[(u + 1) * 5 + v + 1];
			}
		}
	if (f_v) {
		cout << "as 4 x 4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		}
}

void O4_to_O5(action *A4, action *A5, finite_field *Fq, 
	INT *mtx4x4, INT *mtx5x5, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT ord;
	INT i, j;
	INT value;
	INT sqrt_value;
	INT discrete_log;
	INT *A4_Elt1;
	INT *A5_Elt1;
	INT gram[16];	
	INT mtx_tr[16];
	INT mtx_tmp1[16];
	INT mtx_tmp2[16];
	INT mtx5[25];
	
	A4_Elt1 = NEW_INT(A4->elt_size_in_INT);
	A5_Elt1 = NEW_INT(A5->elt_size_in_INT);
	
	A4->make_element(A4_Elt1, mtx4x4, 0);
	if (f_v) {
		cout << "A4_Elt1:" << endl;
		A4->element_print_quick(A4_Elt1, cout);
		}
	ord = A4->element_order(A4_Elt1);
	if (f_v) {
		cout << "A4_Elt1 has order " << ord << endl;
		}


	for (i = 0; i < 16; i++) {
		gram[i] = 0;
		}
	gram[0 * 4 + 1] = 1;
	gram[1 * 4 + 0] = 1;
	gram[2 * 4 + 3] = 1;
	gram[3 * 4 + 2] = 1;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx_tr[i * 4 + j] = mtx4x4[j * 4 + i];
			}
		}
	if (f_v) {
		cout << "Gram matrix:" << endl;
		print_integer_matrix_width(cout, gram, 4, 4, 4, 3);
		cout << "mtx4x4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		cout << "mtx_tr:" << endl;
		print_integer_matrix_width(cout, mtx_tr, 4, 4, 4, 3);
		}
	Fq->mult_matrix(mtx4x4, gram, mtx_tmp1, 4, 4, 4);
	Fq->mult_matrix(mtx_tmp1, mtx_tr, mtx_tmp2, 4, 4, 4);
	if (f_v) {
		cout << "transformed Gram matrix:" << endl;
		print_integer_matrix_width(cout, mtx_tmp2, 4, 4, 4, 3);
		}
	
	value = 0;
	for (i = 0; i < 16; i++) {
		if (!mtx_tmp2[i]) {
			continue;
			}
		if (value == 0) {
			value = mtx_tmp2[i];
			continue;
			}
		if (value != mtx_tmp2[i]) {
			cout << "the transformed gram matrix has several values" << endl;
			exit(1);
			}
		value = mtx_tmp2[i];
		}

	if (f_v) {
		cout << "value=" << value << endl;
		}
	discrete_log = Fq->log_alpha(value);

	if (f_v) {
		cout << "discrete_log=" << discrete_log << endl;
		}
	if (ODD(discrete_log)) {
		cout << "value is not a square" << endl;
		exit(1);
		}
	sqrt_value = Fq->alpha_power(discrete_log >> 1);
	
	
	for (i = 0 ; i < 25; i++) {
		mtx5[i] = 0;
		}
	mtx5[0] = sqrt_value;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx5[(i + 1) * 5 + j + 1] = mtx4x4[i * 4 + j];
			}
		}

	
	A5->make_element(A5_Elt1, mtx5, 0);
	if (f_v) {
		cout << "A5_Elt1:" << endl;
		A5->element_print_quick(A5_Elt1, cout);
		}
	ord = A5->element_order_verbose(A5_Elt1, 0);
	if (f_v) {
		cout << "A5_Elt1 has order " << ord << endl;
		}
	for (i = 0; i < 25; i++) {
		mtx5x5[i] = A5_Elt1[i];
		}

	FREE_INT(A4_Elt1);
	FREE_INT(A5_Elt1);
}

void print_4x4_as_2x2(action *A2, finite_field *Fq, INT *mtx4x4)
{
	INT small[8], f_switch, r, order;
	INT *elt1;
		
	elt1 = NEW_INT(A2->elt_size_in_INT);	
	O4_isomorphism_4to2(Fq, small, small + 4, f_switch, mtx4x4, 0/*verbose_level*/);
	cout << "after isomorphism:" << endl;
	cout << "f_switch=" << f_switch << endl;
	for (r = 0; r < 2; r++) {
		cout << "component " << r << ":" << endl;
		PG_element_normalize_from_front(*Fq, small + r * 4, 1, 4);
		print_integer_matrix_width(cout, small + r * 4, 2, 2, 2, 3);
		A2->make_element(elt1, small + r * 4, 0);
		order = A2->element_order(elt1);
		cout << "has order " << order << endl;
		A2->element_print_as_permutation(elt1, cout);
		cout << endl;
		A2->element_print_quick(elt1, cout);
		cout << endl;
		
		}
	FREE_INT(elt1);
}

INT reverse_engineer_semilinear_map(action *A, projective_space *P, 
	INT *Elt, INT *Mtx, INT &frobenius, 
	INT verbose_level)
// uses the function A->element_image_of
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	finite_field *F;
	INT d = P->n + 1;
	INT *v1, *v2, *v1_save;
	INT *w1, *w2, *w1_save;
	INT q, h, hh, i, j, l, e, frobenius_inv, lambda, rk, c, cv;
	INT *system;
	INT *base_cols;
	

	if (f_v) {
		cout << "reverse_engineer_semilinear_map" << endl;
		cout << "verbose_level=" << verbose_level << endl;
		cout << "d=" << d << endl;
		}
	F = P->F;
	q = F->q;
	
	v1 = NEW_INT(d);
	v2 = NEW_INT(d);
	v1_save = NEW_INT(d);
	w1 = NEW_INT(d);
	w2 = NEW_INT(d);
	w1_save = NEW_INT(d);
	


	if (f_v) {
		cout << "reverse_engineer_semilinear_map maping unit vectors" << endl;
		}
	for (e = 0; e < d; e++) {
		// map the unit vector e_e (with a one in position e and zeros elsewhere):
		for (h = 0; h < d; h++) {
			if (h == e) {
				v1[h] = 1;
				}
			else {
				v1[h] = 0;
				}				
			}
		INT_vec_copy(v1, v1_save, d);
#if 0
		for (hh = 0; hh < d; hh++) {
			v1_save[hh] = v1[hh];
			}
#endif
		i = P->rank_point(v1);
			// Now, the value of i should be equal to e.
		j = A->element_image_of(i, Elt, 0);
		P->unrank_point(v2, j);
		if (f_vv) {
			print_from_to(d, i, j, v1_save, v2);
			}


		INT_vec_copy(v2, Mtx + e * d, d);
#if 0
		for (hh = 0; hh < d; hh++) {
			Mtx[e * d + hh] = v2[hh];
			}
#endif
		}

	if (f_vv) {
		cout << "Mtx (before scaling):" << endl;
		print_integer_matrix_width(cout, Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		}

	// map the vector (1,1,...,1):
	if (f_v) {
		cout << "reverse_engineer_semilinear_map mapping the all-one vector" << endl;
		}
	for (h = 0; h < d; h++) {
		v1[h] = 1;
		}
	INT_vec_copy(v1, v1_save, d);
#if 0
	for (hh = 0; hh < d; hh++) {
		v1_save[hh] = v1[hh];
		}
#endif
	i = P->rank_point(v1);
	j = A->element_image_of(i, Elt, 0);
	P->unrank_point(v2, j);
	if (f_vv) {
		print_from_to(d, i, j, v1_save, v2);
		}

	system = NEW_INT(d * (d + 1));
	base_cols = NEW_INT(d + 1);
	// coefficient matrix:
	for (i = 0; i < d; i++) {
		for (j = 0; j < d; j++) {
			system[i * (d + 1) + j] = Mtx[j * d + i];
			}
		}
	// RHS:
	for (i = 0; i < d; i++) {
		system[i * (d + 1) + d] = v2[i];
		}
	rk = F->Gauss_simple(system, d, d + 1, base_cols, verbose_level - 4);
	if (rk != d) {
		cout << "rk != d, fatal" << endl;
		exit(1);
		}
	if (f_vv) {
		cout << "after Gauss_simple:" << endl;
		print_integer_matrix_width(cout, system, d, d + 1, d + 1, F->log10_of_q);
		cout << endl;
		}
	for (i = 0; i < d; i++) {
		c = system[i * (d + 1) + d];
		for (j = 0; j < d; j++) {
			Mtx[i * d + j] = F->mult(c, Mtx[i * d + j]);
			}
		}

	if (f_vv) {
		cout << "Mtx (after scaling):" << endl;
		print_integer_matrix_width(cout, Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		}


	// figure out the frobenius:
	if (f_v) {
		cout << "projective_space::reverse_engineer_semilinear_map figuring out the frobenius" << endl;
		}

	if (F->q != F->p) {

		// create the vector (1,p,0,...,0)

		for (h = 0; h < d; h++) {
			if (h == 0) {
				v1[h] = 1;
				}
			else if (h == 1) {
				v1[h] = F->p;
				}
			else {
				v1[h] = 0;
				}				
			}
		INT_vec_copy(v1, v1_save, d);
#if 0
		for (hh = 0; hh < d; hh++) {
			v1_save[hh] = v1[hh];
			}
#endif
		i = P->rank_point(v1);
		j = A->element_image_of(i, Elt, 0);
		P->unrank_point(v2, j);


		if (f_vv) {
			print_from_to(d, i, j, v1_save, v2);
			}


		// coefficient matrix:
		for (i = 0; i < d; i++) {
			for (j = 0; j < 2; j++) {
				system[i * 3 + j] = Mtx[j * d + i];
				}
			}
		// RHS:
		for (i = 0; i < d; i++) {
			system[i * 3 + 2] = v2[i];
			}
		rk = F->Gauss_simple(system, d, 3, base_cols, verbose_level - 4);
		if (rk != 2) {
			cout << "rk != 2, fatal" << endl;
			exit(1);
			}
		if (f_vv) {
			cout << "after Gauss_simple:" << endl;
			print_integer_matrix_width(cout, system, 2, 3, 3, F->log10_of_q);
			cout << endl;
			}

		c = system[0 * 3 + 2];
		if (c != 1) {
			cv = F->inverse(c);
			for (hh = 0; hh < 2; hh++) {
				system[hh * 3 + 2] = F->mult(cv, system[hh * 3 + 2]);
				}
			}
		if (f_vv) {
			cout << "after scaling the last column:" << endl;
			print_integer_matrix_width(cout, system, 2, 3, 3, F->log10_of_q);
			cout << endl;
			}
		lambda = system[1 * 3 + 2];
		if (f_vv) {
			cout << "lambda=" << lambda << endl;
			}
			

		l = F->log_alpha(lambda);
		if (f_vv) {
			cout << "l=" << l << endl;
			}
		for (i = 0; i < F->e; i++) {
			if (i_power_j(F->p, i) == l) {
				frobenius = i;
				break;
				}
			}
		if (i == F->e) {
			cout << "problem figuring out the Frobenius" << endl;
			exit(1);
			}

		}
	else {
		frobenius = 0;
		}

	frobenius_inv = (F->e - frobenius) % F->e;
	if (f_vv) {
		cout << "frobenius = " << frobenius << endl;
		cout << "frobenius_inv = " << frobenius_inv << endl;
		}


	for (hh = 0; hh < d * d; hh++) {
		Mtx[hh] = F->frobenius_power(Mtx[hh], frobenius_inv);
		}
	if (f_v) {
		cout << "projective_space::reverse_engineer_semilinear_map done, we found the following map" << endl;
		cout << "Mtx:" << endl;
		print_integer_matrix_width(cout, Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		cout << "frobenius = " << frobenius << endl;
		}



	FREE_INT(v1);
	FREE_INT(v2);
	FREE_INT(v1_save);
	FREE_INT(w1);
	FREE_INT(w2);
	FREE_INT(w1_save);
	FREE_INT(system);
	FREE_INT(base_cols);


	return TRUE;
}

static void print_from_to(INT d, INT i, INT j, INT *v1, INT *v2)
{
	cout << i << "=";
	INT_vec_print(cout, v1, d);
	cout << " -> " << j << " = ";
	INT_vec_print(cout, v2, d);
	cout << endl;
}




sims *set_stabilizer_in_projective_space(
	action *A_linear, projective_space *P, 
	INT *set, INT set_size, INT verbose_level)
// added 2/28/2011, called from analyze.C
// November 17, 2014 moved here from TOP_LEVEL/extra.C
// December 31, 2014, moved here from projective_space.C
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT f_vvv = (verbose_level >= 5);
	INT *Incma;
	INT *partition;
	INT *labeling;
	INT nb_rows, nb_cols;
	INT *Aut, Aut_counter;
	INT *Base, Base_length;
	INT *Transversal_length, Ago;
	INT N, i, j, h;

	if (f_v) {
		cout << "set_stabilizer_in_projective_space" << endl;
		cout << "verbose_level = " << verbose_level << endl;
		cout << "set_size = " << set_size << endl;
		}
	if (P->incidence_bitvec == NULL) {
		cout << "set_stabilizer_in_projective_space P->incidence_bitvec == NULL" << endl;
		exit(1);
		}

	if (f_vv) {
		cout << "computing the type of the set" << endl;
		}

	classify C;

	C.init(set, set_size, TRUE, 0);
	if (C.second_nb_types > 1) {
		cout << "set_stabilizer_in_projective_space: The set is a multiset:" << endl;
		C.print(FALSE /*f_backwards*/);
		}

	if (f_vv) {
		cout << "allocating data" << endl;
		}
	nb_rows = P->N_points + 1;
	nb_cols = P->N_lines + C.second_nb_types;
	Incma = NEW_INT(nb_rows * nb_cols);
	partition = NEW_INT(nb_rows + nb_cols);
	labeling = NEW_INT(nb_rows + nb_cols);

	if (f_vv) {
		cout << "Initializing Incma" << endl;
		}

	for (i = 0; i < P->N_points; i++) {
		for (j = 0; j < P->N_lines; j++) {
			Incma[i * nb_cols + j] = P->is_incident(i, j);
			}
		}
	// last columns, make zero:
	for (j = 0; j < C.second_nb_types; j++) {
		for (i = 0; i < P->N_points; i++) {
			Incma[i * nb_cols + P->N_lines + j] = 0;
			}
		}
	
	// last row, make zero:
	for (j = 0; j < nb_cols; j++) {
		Incma[P->N_points * nb_cols + j] = 0;
		}

	// last columns:
	for (j = 0; j < C.second_nb_types; j++) {
		INT f2, l2, m, idx, f, l;

		f2 = C.second_type_first[j];
		l2 = C.second_type_len[j];
		m = C.second_data_sorted[f2 + 0];
		if (f_vvv) {
			cout << "j=" << j << " f2=" << f2 << " l2=" << l2 << " multiplicity=" << m << endl;
			}
		for (h = 0; h < l2; h++) {
			idx = C.second_sorting_perm_inv[f2 + h];
			f = C.type_first[idx];
			l = C.type_len[idx];
			i = C.data_sorted[f + 0];
			if (f_vvv) {
				cout << "h=" << h << " idx=" << idx << " f=" << f << " l=" << l << " i=" << i << endl;
				}
			Incma[i * nb_cols + P->N_lines + j] = 1;
			}	
#if 0
		for (h = 0; h < set_size; h++) {
			i = set[h];
			Incma[i * nb_cols + N_lines + j] = 1;
			}
#endif
		}
	// bottom right entries:
	for (j = 0; j < C.second_nb_types; j++) {
		Incma[P->N_points * nb_cols + P->N_lines + j] = 1;
		}

	if (f_vvv) {
		cout << "Incma:" << endl;
		print_integer_matrix_width(cout, Incma, nb_rows, nb_cols, nb_cols, 1);
		}

	if (f_vv) {
		cout << "initializing partition" << endl;
		}
	N = nb_rows + nb_cols;
	for (i = 0; i < N; i++) {
		partition[i] = 1;
		}
	partition[P->N_points - 1] = 0;
	partition[P->N_points] = 0;
	partition[nb_rows + P->N_lines - 1] = 0;
	for (j = 0; j < C.second_nb_types; j++) {
		partition[nb_rows + P->N_lines + j] = 0;
		}
	if (f_vvv) {
		cout << "partition:" << endl;
		for (i = 0; i < N; i++) {
			cout << i << " : " << partition[i] << endl;
			}
		}

	if (f_vv) {
		cout << "initializing Aut, Base, Transversal_length" << endl;
		}
	Aut = NEW_INT(N * N);
	Base = NEW_INT(N);
	Transversal_length = NEW_INT(N);
	
	if (f_v) {
		cout << "set_stabilizer_in_projective_space, calling nauty_interface_matrix_INT" << endl;
		}
	nauty_interface_matrix_INT(Incma, nb_rows, nb_cols, 
		labeling, partition, 
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago, verbose_level - 1);
	if (f_v) {
		cout << "set_stabilizer_in_projective_space, done with nauty_interface_matrix_INT, Ago=" << Ago << endl;
		}


	action *A_perm;


	A_perm = new action;

	A_perm->init_permutation_group_from_generators(N, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level - 2);

	if (f_v) {
		cout << "set_stabilizer_in_projective_space: create_automorphism_group_of_incidence_structure: created action ";
		A_perm->print_info();
		cout << endl;
		}

	//action *A_linear;

	//A_linear = A;

	if (A_linear == NULL) {
		cout << "set_stabilizer_in_projective_space: A_linear == NULL" << endl;
		exit(1);
		}

	vector_ge *gens; // permutations from nauty
	vector_ge *gens1;
	INT d, g, frobenius, pos;
	INT *Mtx;
	INT *Elt1;

	Elt1 = NEW_INT(A_linear->elt_size_in_INT);

	d = P->n + 1;
	
	gens = A_perm->Strong_gens->gens;
	//gens = A->strong_generators;

	gens1 = new vector_ge;
	gens1->init(A_linear);
	gens1->allocate(gens->len);
	
	Mtx = NEW_INT(d * d + 1); // leave space for frobenius
	
	pos = 0;
	for (g = 0; g < gens->len; g++) {
		if (f_vv) {
			cout << "set_stabilizer_in_projective_space: strong generator " << g << ":" << endl;
			A_perm->element_print(gens->ith(g), cout);
			cout << endl;
			}
		
		if (reverse_engineer_semilinear_map(A_perm, P, 
			gens->ith(g), Mtx, frobenius, 
			verbose_level - 2)) {

			Mtx[d * d] = frobenius;
			A_linear->make_element(Elt1, Mtx, verbose_level - 2);
			if (f_vv) {
				cout << "semi-linear group element:" << endl;
				A_linear->element_print(Elt1, cout);
				}
			A_linear->element_move(Elt1, gens1->ith(pos), 0);
		

			pos++;
			}
		else {
			if (f_vv) {
				cout << "set_stabilizer_in_projective_space: generator " << g << " does not correspond to a semilinear mapping" << endl;
				}
			}
		}
	gens1->reallocate(pos);
	if (f_v) {
		cout << "we found " << gens1->len << " generators" << endl;
		}

	if (f_vv) {
		gens1->print(cout);
		}
	

	if (f_v) {
		cout << "set_stabilizer_in_projective_space: we are now testing the generators:" << endl;
		}
	INT *v, *w, *z, *zz, j1, j2;
	
	v = NEW_INT(d);
	w = NEW_INT(d);
	z = NEW_INT(d);
	zz = NEW_INT(d);
	for (g = 0; g < gens1->len; g++) {
		if (f_vv) {
			cout << "generator " << g << ":" << endl;
			}
		//A_linear->element_print(gens1->ith(g), cout);
		for (i = 0; i < P->N_points; i++) {
			j1 = A_linear->element_image_of(i, gens1->ith(g), 0);
			j2 = A_perm->element_image_of(i, gens->ith(g), 0);
			if (j1 != j2) {
				cout << "problem: j1 != j2" << endl;
				cout << "i=" << i << endl;
				cout << "j1=" << j1 << endl;
				cout << "j2=" << j2 << endl;
				cout << endl;
				exit(1);
				}
			}
		}
	if (f_v) {
		cout << "set_stabilizer_in_projective_space: the generators are OK" << endl;
		}



	sims *S;
	longinteger_object go;

	if (f_v) {
		cout << "set_stabilizer_in_projective_space: we are now creating the group" << endl;
		}

	S = create_sims_from_generators_without_target_group_order(A_linear, 
		gens1, verbose_level - 4);
	S->group_order(go);
	if (f_v) {
		cout << "set_stabilizer_in_projective_space: Found a group of order " << go << endl;
		}
	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: strong generators are:" << endl;
		S->print_generators();
		cout << "set_stabilizer_in_projective_space: strong generators are (in tex):" << endl;
		S->print_generators_tex(cout);
		}



	FREE_INT(Aut);
	FREE_INT(Base);
	FREE_INT(Transversal_length);
	FREE_INT(Incma);
	FREE_INT(partition);
	FREE_INT(labeling);
	delete A_perm;
	delete gens1;
	FREE_INT(Mtx);
	FREE_INT(Elt1);
	FREE_INT(v);
	FREE_INT(w);
	FREE_INT(z);
	FREE_INT(zz);
	//delete A_linear;

	if (f_v) {
		cout << "set_stabilizer_in_projective_space done" << endl;
		}
	return S;
}


void projective_space_init_line_action(projective_space *P, action *A_points, action *&A_on_lines, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	action_on_grassmannian *AoL;

	if (f_v) {
		cout << "projective_space_init_line_action" << endl;
		}
	A_on_lines = NEW_OBJECT(action);

	AoL = NEW_OBJECT(action_on_grassmannian);

	AoL->init(*A_points, P->Grass_lines, verbose_level - 5);
	
	
	if (f_v) {
		cout << "projective_space_init_line_action action on grassmannian established" << endl;
		}

	if (f_v) {
		cout << "projective_space_init_line_action initializing A_on_lines" << endl;
		}
	INT f_induce_action = TRUE;
	sims S;
	longinteger_object go1;

	S.init(A_points);
	S.init_generators(*A_points->Strong_gens->gens, 0/*verbose_level*/);
	S.compute_base_orbits_known_length(A_points->transversal_length, 0/*verbose_level - 1*/);
	S.group_order(go1);
	if (f_v) {
		cout << "projective_space_init_line_action group order " << go1 << endl;
		}
	
	if (f_v) {
		cout << "projective_space_init_line_action initializing action on grassmannian" << endl;
		}
	A_on_lines->induced_action_on_grassmannian(A_points, AoL, 
		f_induce_action, &S, verbose_level);
	if (f_v) {
		cout << "projective_space_init_line_action initializing A_on_lines done" << endl;
		A_on_lines->print_info();
		}

	if (f_v) {
		cout << "projective_space_init_line_action computing strong generators" << endl;
		}
	if (!A_on_lines->f_has_strong_generators) {
		cout << "projective_space_init_line_action induced action does not have strong generators" << endl;
		}
	if (f_v) {
		cout << "projective_space_init_line_action done" << endl;
		}
}

void color_distribution_matrix(action *A, INT *Elt, INT n, UBYTE *Adj, INT *colors, classify *C, 
	INT *&Mtx, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT i, j, ci, cj;

	if (f_v) {
		cout << "color_distribution_matrix" << endl;
		}
	
	Mtx = NEW_INT(C->nb_types * C->nb_types);
	INT_vec_zero(Mtx, C->nb_types * C->nb_types);
	
	for (i = 0; i < n; i++) {
		ci = C->class_of(i);
		j = A->element_image_of(i, Elt, 0 /* verbose_level */);
		cj = C->class_of(j);
		Mtx[ci * C->nb_types + cj]++;
		}
	
	if (f_v) {
		cout << "color_distribution_matrix done" << endl;
		}
}

void test_color_distribution(action *A, vector_ge *gens, INT n, UBYTE *Adj, INT *colors, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = FALSE; //(verbose_level >= 1);
	INT *Elt;
	INT *Mtx;
	INT l, h;

	if (f_v) {
		cout << "test_color_distribution" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	l = gens->len;
	for (h = 0; h < l; h++) {
		Elt = gens->ith(h);
		color_distribution_matrix(A, Elt, n, Adj, colors, &C, 
			Mtx, verbose_level - 2);
		if (f_vv) {
			cout << "generator " << h << " has the following color distribution matrix:" << endl;
			INT_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		
		FREE_INT(Mtx);
		}

	if (f_v) {
		cout << "test_color_distribution done" << endl;
		}
}

void color_preserving_subgroup(action *A, INT n, UBYTE *Adj, INT *colors, sims *&Subgroup, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT f_vv = FALSE; //(verbose_level >= 2);
	sims *S;
	INT *Elt;
	INT *Subgrp;
	sims *K;
	INT sz;
	INT h, go;
	longinteger_object Go;
	vector_ge *gens;

	if (f_v) {
		cout << "color_preserving_subgroup" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	S = A->Sims;
	Elt = NEW_INT(A->elt_size_in_INT);
	
	go = S->group_order_INT();
	Subgrp = NEW_INT(go);
	sz = 0;

	for (h = 0; h < go; h++) {
		INT *Mtx;
		
		S->element_unrank_INT(h, Elt);
		color_distribution_matrix(A, Elt, n, Adj, colors, &C, 
			Mtx, verbose_level - 2);

		if (f_vv) {
			cout << "element " << h << " / " << go << " has the following color distribution matrix:" << endl;
			INT_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		if (is_diagonal_matrix(Mtx, C.nb_types)) {
			Subgrp[sz++] = h;
			}
		FREE_INT(Mtx);
		}


	if (f_v) {
		cout << "The subgroup has order " << sz << endl;
		cout << "and consists of the elements: ";
		INT_vec_print(cout, Subgrp, sz);
		cout << endl;
		}
	
	gens = new vector_ge;
	gens->init(A);
	gens->allocate(sz);
	for (h = 0; h < sz; h++) {
		S->element_unrank_INT(Subgrp[h], gens->ith(h));
		}
	
	Subgroup = new sims;
	K = new sims;
	Go.create(sz);
	Subgroup->init(A);
	K->init(A);
	Subgroup->init_trivial_group(verbose_level);
	K->init_trivial_group(verbose_level);
	Subgroup->build_up_group_from_generators(K, gens, 
		TRUE /* f_target_go */, &Go, 
		FALSE /* f_override_choose_next_base_point */,
		NULL, 
		verbose_level);
	

	FREE_INT(Elt);
	FREE_INT(Subgrp);
	delete gens;
	delete K;

	if (f_v) {
		cout << "color_preserving_subgroup done" << endl;
		}
}

INT test_automorphism_group_of_graph_bitvec(action *A, INT n, UBYTE *Adj, INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	strong_generators *SG;
	INT *Elt;
	INT h, i, j, ii, jj, iii, jjj, k, kk, l, a, b;

	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec" << endl;
		}

	SG = A->Strong_gens;
	l = SG->gens->len;
	for (h = 0; h < l; h++) {
		Elt = SG->gens->ith(h);
		for (i = 0; i < n; i++) {
			ii = A->element_image_of(i, Elt, 0 /* verbose_level */);
			for (j = i + 1; j < n; j++) {
				jj = A->element_image_of(j, Elt, 0 /* verbose_level */);
				if (ii < jj) {
					iii = ii;
					jjj = jj;
					}
				else {
					iii = jj;
					jjj = ii;
					}
				k = ij2k(i, j, n);
				kk = ij2k(iii, jjj, n);
				a = bitvector_s_i(Adj, k);
				b = bitvector_s_i(Adj, kk);
				if (a && !b) {
					cout << "automorphism does not preserve adjacency" << endl;
					return FALSE;
					}
				if (!a && b) {
					cout << "automorphism does not preserve adjacency" << endl;
					return FALSE;
					}
				}
			}
		}
	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec done" << endl;
		}
	return TRUE;
}

void compute_conjugacy_classes(sims *S, action *&Aconj, action_by_conjugation *&ABC, schreier *&Sch, 
	strong_generators *&SG, INT &nb_classes, INT *&class_size, INT *&class_rep, 
	INT verbose_level)
{
	INT f_v = (verbose_level >= 1);
	INT i, f;

	if (f_v) {
		cout << "compute_conjugacy_classes" << endl;
		}
	Aconj = new action;

	if (f_v) {
		cout << "Creating action by conjugation" << endl;
		}
	
	Aconj->induced_action_by_conjugation(S, 
		S, FALSE /* f_ownership */, FALSE /* f_basis */, verbose_level - 1);

	if (f_v) {
		cout << "Creating action by conjugation done" << endl;
		}	

	ABC = Aconj->G.ABC;


	Sch = new schreier;

	Sch->init(Aconj);


	SG = new strong_generators;

	SG->init_from_sims(S, 0);
	

	Sch->init_generators(*SG->gens);

	if (f_v) {
		cout << "Computing conjugacy classes:" << endl;
		}
	Sch->compute_all_point_orbits(verbose_level);
	

	nb_classes = Sch->nb_orbits;

	class_size = NEW_INT(nb_classes);
	class_rep = NEW_INT(nb_classes);
	
	for (i = 0; i < nb_classes; i++) {
		class_size[i] = Sch->orbit_len[i];
		f = Sch->orbit_first[i];
		class_rep[i] = Sch->orbit[f];
		}

	if (f_v) {
		cout << "class size : ";
		INT_vec_print(cout, class_size, nb_classes);
		cout << endl;
		cout << "class rep : ";
		INT_vec_print(cout, class_rep, nb_classes);
		cout << endl;
		}


	if (f_v) {
		cout << "compute_conjugacy_classes done" << endl;
		}

}

INT group_ring_element_size(action *A, sims *S)
{
	INT goi;

	goi = S->group_order_INT();
	return goi;
}

void group_ring_element_create(action *A, sims *S, INT *&elt)
{
	INT goi;

	goi = S->group_order_INT();
	elt = NEW_INT(goi);
	group_ring_element_zero(A, S, elt);
}

void group_ring_element_free(action *A, sims *S, INT *elt)
{
	FREE_INT(elt);
}

void group_ring_element_print(action *A, sims *S, INT *elt)
{
	INT goi;

	goi = S->group_order_INT();
	INT_vec_print(cout, elt, goi);
}

void group_ring_element_copy(action *A, sims *S, INT *elt_from, INT *elt_to)
{
	INT goi;

	goi = S->group_order_INT();
	INT_vec_copy(elt_from, elt_to, goi);
}

void group_ring_element_zero(action *A, sims *S, INT *elt)
{
	INT goi;

	goi = S->group_order_INT();
	INT_vec_zero(elt, goi);
}

void group_ring_element_mult(action *A, sims *S, INT *elt1, INT *elt2, INT *elt3)
{
	INT goi;
	INT i, j, k;
	INT a, b, c;

	goi = S->group_order_INT();
	INT_vec_zero(elt3, goi);
	for (i = 0; i < goi; i++) {
		a = elt1[i];
		for (j = 0; j < goi; j++) {
			b = elt2[j];
			c = a * b;
			k = S->mult_by_rank(i, j, 0 /* verbose_level */);
			elt3[k] += c;
			}
		}
}


void perm_print_cycles_sorted_by_length(ostream &ost, INT degree, INT *perm, INT verbose_level)
{
	perm_print_cycles_sorted_by_length_offset(ost, degree, perm, 0, FALSE, TRUE, verbose_level);
}

void perm_print_cycles_sorted_by_length_offset(ostream &ost, 
	INT degree, INT *perm, INT offset, INT f_do_it_anyway_even_for_big_degree, 
	INT f_print_cycles_of_length_one, INT verbose_level)
{
	INT nb_gens = 1;
	INT i;
	vector_ge Gens;
	action *A;
	INT f_v = (verbose_level >= 1);
	INT f_vv = (verbose_level >= 2);
	INT f_big = FALSE;
	INT f_doit = TRUE;
	
	if (f_v) {
		cout << "perm_print_cycles_sorted_by_length, degree=" << degree << endl;
		}
	
	if (degree > 500) {
		f_big = TRUE;
		}
	A = new action;
	
	A->init_permutation_group(degree, 0/*verbose_level*/);
	Gens.init(A);
	Gens.allocate(nb_gens);
	for (i = 0; i < nb_gens; i++) {
		Gens.copy_in(i, perm + i * degree);
		}
	if (f_vv) {
		Gens.print(cout);
		}
	
	schreier S;
	
	S.init(A);
	S.init_generators(Gens);
	S.compute_all_point_orbits(verbose_level);
	if (f_v) {
		cout << "after S.compute_all_point_orbits, nb_orbits=" << S.nb_orbits << endl;
		}
	//S.print_orbit_lengths(cout);
	//S.print_orbit_length_distribution(ost);

	INT j, f, l, length, F, L, h, a, b, m, orbit_idx;
	INT *orbit_len_sorted;
	INT *sorting_perm;
	INT *sorting_perm_inv;
	INT nb_types;
	INT *type_first;
	INT *type_len;
	
	INT_vec_classify(S.nb_orbits, S.orbit_len, orbit_len_sorted, 
		sorting_perm, sorting_perm_inv, 
		nb_types, type_first, type_len);

#if 0
	ost << "permutation of degree " << degree << " with " << S.nb_orbits << " orbits: " << endl;
	for (i = 0; i < nb_types; i++) {
		f = type_first[i];
		l = type_len[i];
		length = orbit_len_sorted[f];
		if (l > 1) {
			ost << l << " \\times ";
			}
		ost << length;
		if (i < nb_types - 1)
			ost << ", ";
		}
	ost << endl;
	ost << "cycles in increasing length:" << endl;
#endif
	if (f_big) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			ost << l << " cycles of length " << length << endl;
			}
		}
	if (f_big && !f_do_it_anyway_even_for_big_degree) {
		f_doit = FALSE;
		}
	if (f_doit) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			if (length == 1 && !f_print_cycles_of_length_one) {
				continue;
				}
			for (j = 0; j < l; j++) {
				orbit_idx = sorting_perm_inv[f + j];
				//ost << "orbit " << orbit_idx << ": ";
				F = S.orbit_first[orbit_idx];
				L = S.orbit_len[orbit_idx];
				m = S.orbit[F];
				for (h = 1; h < L; h++) {
					if (S.orbit[F + h] < m)
						m = S.orbit[F + h];
					}
				// now m is the least lement in the orbit
				ost << "(";
				a = m;
				ost << (a + offset);
				while (TRUE) {
					b = perm[a];
					if (b == m)
						break;
					ost << ", " << (b + offset);
					a = b;
					}
				ost << ")";
				if (length > 20) {
					//ost << endl;
					}
				} // next j
			//ost << endl;
			} // next i
		} // if
	//ost << "done" << endl;

#if 0
	classify C;

	C.init(S.orbit_len, S.nb_orbits, FALSE, 0);
	ost << " cycle type: ";
	C.print_file(ost, TRUE /* f_backwards */);
#endif

	FREE_INT(orbit_len_sorted);
	FREE_INT(sorting_perm);
	FREE_INT(sorting_perm_inv);
	FREE_INT(type_first);
	FREE_INT(type_len);
	
	delete A;
}


